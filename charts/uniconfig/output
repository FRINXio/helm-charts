---
# Source: uniconfig/charts/traefik/templates/rbac/serviceaccount.yaml
kind: ServiceAccount
apiVersion: v1
metadata:
  name: uniconfig
  namespace: default
  labels:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/instance: fm-default
    helm.sh/chart: traefik-20.8.0
    app.kubernetes.io/managed-by: Helm
  annotations:
---
# Source: uniconfig/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: uniconfig-controller
  labels:
    helm.sh/chart: uniconfig-3.0.4
    app.kubernetes.io/name: uniconfig
    app.kubernetes.io/instance: fm
    app.kubernetes.io/version: "5.0.12"
    app.kubernetes.io/managed-by: Helm
---
# Source: uniconfig/charts/postgresql/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: fm-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.9.13
    app.kubernetes.io/instance: fm
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  postgres-password: "VmNSc1NSMUJneg=="
  password: "cG9zdGdyZXNQ"
  # We don't auto-generate LDAP password when it's not provided as we do for other passwords
---
# Source: uniconfig/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: uniconfig-controller
data:
  dbPersistence_connection_username: cG9zdGdyZXNV
  dbPersistence_connection_password: cG9zdGdyZXNQ
---
# Source: uniconfig/templates/configmap-lighty-uniconfig-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: uniconfig-controller-configmap-lighty-uniconfig-config
data:
  lighty-uniconfig-config.json: |-
    {
        // Controller configuration.
        "controller": {
            // DOM notification service - settings related to notifications queue.
            "domNotificationRouterConfig": {
                // size of the notification queue
                "queueDepth": 65536,
                // the maximum time in to busy spin for (see PhasedBackoffWaitStrategy)
                "spinTime": 0,
                // the maximum time in to yield for (see PhasedBackoffWaitStrategy)
                "parkTime": 0,
                // time unit that expresses values of spin-time and park-time.
                "unit": "MILLISECONDS"
            },
            /*
            Contains list of paths to artifacts containing YANG modules for UniConfig schema
            and identifiers of the schema directories.
            */
            "schemaServiceConfig": {
                // set of YANG modules that are loaded at initialization of UniConfig
                "topLevelModules": [],
                // path to the root cache directory that holds custom schemas
                "rootCacheDirectory": "cache",
                // path to the directory to which system YANG schemas are loaded
                "systemSchemasDirectory": "schemas"
            },
            // Settings related to configuration datastore and associated data-change events
            "configurationDatastoreConfig": {
                // maximum thread pool size for the data change notification executor
                "maxDataChangeExecutorPoolSize": 20,
                // maximum queue size for the data change notification executor
                "maxDataChangeExecutorQueueSize": 1000,
                // maximum queue size for the data change listeners
                "maxDataChangeListenerQueueSize": 1000,
                // maximum queue size for the data store executor
                "maxDataStoreExecutorQueueSize": 5000
            },
            // Settings related to operational datastore and associated data-change events
            "operationalDatastoreConfig": {
                // maximum thread pool size for the data change notification executor
                "maxDataChangeExecutorPoolSize": 20,
                // maximum queue size for the data change notification executor
                "maxDataChangeExecutorQueueSize": 1000,
                // maximum queue size for the data change listeners
                "maxDataChangeListenerQueueSize": 1000,
                // maximum queue size for the data store executor
                "maxDataStoreExecutorQueueSize": 5000
            }
        },
        // RESTCONF and web server settings
        "restconf": {
            // listening web server port
            "httpPort": 8181,
            // IP address on which web server is listening to incoming requests (0.0.0.0 - addresses of all interfaces)
            "inetAddress": "0.0.0.0",
            // common URL prefix under which all resources and operations are registered
            "restconfServletContextPath": "/rests",
            // delimiter used for escaping of list keys in URI (for example, '%22')
            // if it is set to 'null' (default), keys cannot be escaped and must be directly encoded according to RFC-8040
            "keyDelimiter": null,
            // Flag that determines if the data node that is empty(means node contains only attribute tag) should be hidden
            // during GET operation.
            "hideEmptyDataNodes": false,
            // Settings related to filtering of data in CRUD operations.
            "schemaFilters": {
                // List of extension definitions that can be used to filter out data during PUT/POST/PATCH operation.
                //"ignoredDataOnWriteByExtensions": [
                //    "tailf:hidden full"
                //],
                // List of extension definitions that can be used to filter out data during GET operation.
                //"hiddenDataOnReadByExtensions": [
                //    "tailf:hidden deprecated",
                //    "tailf:hidden debug"
                //],
                // Indicates if the data for non-existing schema nodes will be ignored during PUT/POST/PATCH operation.
                "ignoreUnsupportedDefinitionsOnWrite": false,
                // Indicates if the definition with "DEPRECATED" status should be hidden during GET operation.
                "hideDeprecatedDefinitionsOnRead": false
            },
            // default value 0 makes the behavior as defined in RFC8040 (returns status code 404 [Not Found]),
            // if changed to anything else, that status code will be returned
            "statusCodeForEmptyGetResponse": 0,
            // this flag removes namespaces from GET response (only if there are no duplicate localnames)
            // (E.g. if there is: namespace1:test and namespace2:test  .. the namespace won't be removed because
            // there would be two identical localnames)
            "showNamespaceInJsonResponse": true
        },
        /*
        CLI shell settings via environment variables.
        Environment variables override settings from JSON config part.
  
        cliShell_sshServer_enabled=false
        cliShell_sshServer_port=2022
        cliShell_sshServer_inetAddress=0.0.0.0
        cliShell_sshServer_usernamePasswordAuth_username=admin
        cliShell_sshServer_usernamePasswordAuth_password=secret
        */
        "cliShell": {
            "sshServer": {
                // Flag that determines if ssh server will be started or not.
                "enabled": false,
                // Port bind to ssh server.
                "port": 2022,
                // IP address bind to ssh server.
                "inetAddress": "127.0.0.1",
                // Basic username + password authentication.
                "usernamePasswordAuth": {
                    "username": "admin",
                    "password": "secret"
                }
            },
            // Flag that determines if uniconfig-shell provides scrolling of output
            "enableScrolling": false,
            // Number of history items to keep in memory
            "historySize": 500,
            // Number of history items to keep in the history file
            "historyFileSize": 1000
        },
        /*
        Settings for the Device Discovery service
        */
        "deviceDiscovery":{
            // A parameter that specifies the local address from which the scanning will be ran.
            "localAddress": "",
            // A parameter that specifies the maximum pool size by the executor.
            // If left empty, the default will be CPU_COUNT * 8.
            //"maxPoolSize": 20,
            // A parameter that specifies the maximum limit of IP addresses that the service can process in one request.
            "addressCheckLimit": 254
        },
        /*
        DB persistence settings via environment variables.
        Environment variables override settings from JSON config part.
  
        dbPersistence_embedded_database_enabled=false
        dbPersistence_embedded_database_dataDir=./data/pg_dir
        dbPersistence_embedded_database_cleanDataDir=true
        dbPersistence_connection_dbName=uniconfig
        dbPersistence_connection_username=uniremote
        dbPersistence_connection_password=unipass
        dbPersistence_connection_initialDbPoolSize=5
        dbPersistence_connection_maxDbPoolSize=10
        dbPersistence_connection_maxIdleConnections=5
        dbPersistence_connection_maxWaitTime=30000
        dbPersistence_connection_enabledTls=false
        dbPersistence_connection_tlsClientCert=./client.pks
        dbPersistence_connection_tlsClientKey=./client.key
        dbPersistence_connection_tlsCaCert=./ca.pks
        dbPersistence_connection_databaseLocations_host=127.0.0.1
        dbPersistence_connection_databaseLocations_port=26257
        dbPersistence_uniconfigInstance_instanceName=uc-0
        */
        "dbPersistence": {
            /*
            Grouped settings that are related to embedded database.
            The embedded database is only for testing purposes, it should not be run in the production environment.
            Database is started and initialized using 'connection'/'dbName' and 'connection'/'username' parameters.
            The embedded database does not use a password, therefore it ignores the password parameter.
            */
            "embeddedDatabase": {
                // Flag that determines if embedded database will be started or not.
                "enabled": false,
                // A parameter that specifies the name of the subdirectory in which the embedded database is stored.
                "dataDir": "./data/pg_dir",
                // A parameter that determines if the 'dataDir' directory will be deleted after uniconfig is turned off.
                "cleanDataDir": true
            },
            // Grouped settings related to database connection.
            "connection": {
                // name of the database
                "dbName": "uniconfig",
                // name of the user that has the remote access to database specified by 'dbName'
                "username": "uniremote",
                // user password (it is used only for the password-base authentication)
                "password": "unipass",
                // initial size of the connection pool (pre-initialized connections)
                "initialDbPoolSize": 5,
                // maximum size of the connection pool, before creation of next connections are blocked
                "maxDbPoolSize": 300,
                // maximum number of idle connections before next idle connections are cleaned
                "maxIdleConnections": 5,
                /*
                Timeout value used for socket read operations. If reading from the server takes longer than this value,
                the connection is closed. This can be used as both a brute force global query timeout and a method of
                detecting network problems. The timeout is specified in seconds and a value of 0 means that it is disabled.
                */
                "socketReadTimeout": 20,
                // maximum wait time for obtaining of a new connection before fetch request is dropped [milliseconds]
                "maxWaitTime": 30000,
                // enabled TLS authentication (if it is enabled, 'tlsClientCert', 'tlsClientKey', and 'tlsCaCert'
                // are used and 'password' field is not used
                "enabledTls": false,
                // path to UniConfig client certificate (relative path from UniConfig main folder)
                // - used for authentication of UniConfig against DB
                "tlsClientCert": "./client.pks",
                // path to UniConfig client certificate key (relative path from UniConfig main folder)
                "tlsClientKey": "./client.key",
                // path to certificate of DB certificate authority - used for authentication of DB against UniConfig
                "tlsCaCert": "./ca.pks",
                /*
                List of network locations at which target database resides. The first entry is always tried in the first
                attempt during creation of database connection. If there are multiple entries specified, then other
                locations are used as fallback method in the order in which they are specified.
                */
                "databaseLocations": [
                    {
                        // database hostname / IP address
                        "host": "127.0.0.1",
                        // TCP port on which target database listens to incoming connections
                        "port": 26257
                    }
                ],
                /*
                Repairs the Flyway schema history table before Flyway migration. This will perform the following actions:
                 1. Remove any failed migrations on databases.
                 2. Realign the checksums, descriptions and types of the applied migrations with available migrations.
                */
                "repairSchemaHistory": false
            },
            // UniConfig instance naming settings.
            "uniconfigInstance": {
                // Identifier of the local UniConfig instance (name must be unique in the cluster). If it is set to 'null'
                // then this identifier is tried to be loaded from 'data/instance_name'. If this file doesn't exist, then
                // name of the UniConfig instance is randomly generated and this file is created with new name of instance.
                "instanceName": null
            },
            // Heart beat service settings.
            "heartBeat": {
                // interval between updating of local UniConfig instance heartbeat timestamp [milliseconds]
                "heartbeatInterval": 1000
            }
        },
        // Template settings
        "templates": {
            // Enabled templates - if it is set to 'false', UniConfig will not prepare YANG modules for templates
            // - creation of templates will not work. Enabled templates consumes more memory than setup without templates.
            "enabled": false,
            /* Name of the YANG module which is used for comparison of loaded YANG repositories based on revision and
               further saving the name of the latest YANG repository. Latest YANG repository is automatically used
               at creation of new template node, if user doesn't specify it explicitly. If this setting is not specified,
               this feature will be disabled.*/
            // "latestSchemaReferenceModuleName": "system"
            // Enabled auto-upgrading of templates that are using old YANG repository to templates with same name
            // and latest YANG repositories (applying version-drop). Before templates are upgraded, they are also backed up.
            "enabledTemplatesUpgrading": false,
            // Maximum age of backup template [days]. After that age, template will be removed from database permanently.
            // Negative value will cause removing of such template immediately at the next UniConfig booting process.
            "maxBackupTemplateAge": -1
        },
        // Grouped settings that are related to Uniconfig transactions.
        "transactions": {
            "maxStoredTransactions": 100,
            /*
            Time after transaction can be closed [seconds] by transaction cleaner.
            */
            "transactionIdleTimeOut": 3600,
            /*
            Maximum transaction age before it can be evicted from transaction registry [seconds].
            Configuring '0' disables cleaning of Uniconfig transactions.
            */
            "maxTransactionAge": 7200,
            /*
            Interval at which expired transactions are closed and cleaned [seconds].
            Expired transaction: transaction which age exceeds 'maxTransactionAge' setting.
            Only dedicated Uniconfig transactions (initialized using 'create-transaction' RPC)
            are cleaned - shared transaction is never removed or invalidated.
             Configuring '0' disables cleaning of Uniconfig transactions.
            */
            "cleaningInterval": 60,
            /*
            Boolean value if the Immediate Commit Model is enabled or not. Default value is true.
            If disabled, only manually created transactions can exist.
            */
            "isImmediateCommitEnabled": true
        },
        // Grouped settings that are related to notifications.
        "notifications": {
            // Flag that determines whether notifications are collected
            "enabled": false,
            "kafka": {
                // Username used for authentication into Kafka brokers (SASL). If it is not set, then authentication
                // is disabled (PLAINTEXT scheme).
                // "username": "kafka",
                // Password used for authentication into Kafka brokers.
                //"password": "kafka",
                "kafkaServers": [
                    {
                        // Address / hostname of the interface on which Kafka broker is listening to incoming connections.
                        "brokerHost": "127.0.0.1",
                        // TCP port on which Kafka broker is listening to incoming connections.
                        "brokerListeningPort": 9092
                    }
                ],
                // Kafka producer settings
                "kafkaProducer": {
                    // Specifies the number of messages that the Kafka handler processes as a batch
                    "batchSize": 16384
                },
                // Flag that determines whether netconf notifications are enabled
                "netconfNotificationsEnabled": true,
                // Flag that determines whether audit logs are enabled
                "auditLogsEnabled": true,
                // Flag that determines whether transaction notifications are enabled
                "transactionNotificationsEnabled": true,
                // Enabled collection and propagation of data-change-events into Kafka.
                "dataChangeEventsEnabled": true,
                // Enabled collection and propagation of connection notifications into Kafka.
                "connectionNotificationsEnabled": true,
                // Unique identifier of topic that is used for storing netconf notifications.
                "netconfNotificationsTopicName": "netconf-notifications",
                // Unique identifier of topic that is used for storing audit logs.
                "auditLogsTopicName": "audit-logs",
                // Unique identifier of topic that is used for storing transaction notifications.
                "transactionsTopicName": "transactions",
                // Unique identifier of the Kafka topic used for distribution of data-change-events.
                "dataChangeEventsTopicName": "data-change-events",
                // Unique identifier of the Kafka topic used for distribution of connection notifications.
                "connectionNotificationsTopicName": "connection-notifications",
                // If only connection notifications for NETCONF stream are enabled.
                "connectionNotificationsNetconfStreamOnly": true,
                // Configuration of how long the send() method and the creation of connection for
                // reading of metadata methods will block. (in ms)
                "blockingTimeout": 60000,
                // Configuration of how long will the producer wait for the acknowledgement of a request. (in ms)
                // If the acknowledgement is not received before the timeout elapses, the producer will resend the
                // request or fail the request if retries are exhausted
                "requestTimeout": 30000,
                // Configuration of the upper bound on the time to report success or failure after a
                // call to send() returns.(in ms)
                // This limits the total time that a record will be delayed prior to sending, the time to
                // await acknowledgement from the broker (if expected), and the time allowed for retriable send failures.
                "deliveryTimeout": 120000,
                // The maximum thread pool size in the executor
                // A thread pool executor is needed to send messages to Kafka
                "maxThreadPoolSize": 8,
                // The maximum capacity of the work queue in the executor
                "queueCapacity": 2048,
                // Embedded Kafka settings (embedded Kafka is disabled by default, it should not be used in the production).
                // Only PLAINTEXT authentication scheme is supported.
                "embeddedKafka": {
                    // If this flag is set to 'true', then embedded Kafka is started during boot process.
                    // Otherwise, all other settings are effectively ignored.
                    "enabled": false,
                    // Directory to which embedded Kafka is downloaded and extracted.
                    "installDir": "/tmp/embedded-kafka",
                    // URL that is used for download of Kafka, if it hasn't been downloaded yet.
                    "archiveUrl": "https://dlcdn.apache.org/kafka/3.1.0/kafka_2.13-3.1.0.tgz",
                    // Directory containing Kafka data files - persisted topics.
                    "dataDir": "./data/embedded-kafka",
                    // Clean data from previous run before starting of Kafka (= disabled persistence).
                    "cleanDataBeforeStart": true,
                    // Number of partitions used for created topic.
                    "partitions": 1
                }
            },
            // Settings related to audit logs
            "auditLogs": {
                // If response body should be included in notification
                "includeResponseBody": false
            },
            // Config for deletion of old notifications from db
            "notificationDbTreshold": {
                // Maximum count of records, after reaching this count oldest records will be deleted
                "maxCount": 10000,
                // Maximum age of records, all older records will be deleted (in hours)
                "maxAge": 100
            },
            // How often should uniconfig check for unassigned netconf notifications subscriptions (in seconds)
            "netconfSubscriptionsMonitoringInterval": 5,
            // How many unassigned netconf subscriptions can be processed within one subscription monitoring interval
            "maxNetconfSubscriptionsPerInterval": 10
        },
        // Initial logging configuration (afterwards it can be updated using RPCs).
        "loggingController": {
            // Configuration of specific logging brokers for different system components.
            "broker": [
                // Logging all NETCONF messages.
                {
                    // Logging broker identifier.
                    "broker-identifier": "netconf_messages",
                    // Enabled/disabled logging.
                    "is-logging-broker-enabled": false,
                    // Configured default logging behaviour - if it is set to 'true', logging is enabled
                    // for all NETCONF devices. Otherwise, it is enabled only for explicitly defined devices
                    // ('device-list' field).
                    "is-logging-enabled-on-all-devices": false
                    // List of devices for which logging is enabled.
                    //"device-list": ["dev1", "dev2"]
                },
                // Logging all southbound NETCONF events related to creation/closing of NETCONF connections.
                {
                    "broker-identifier": "netconf_events",
                    "is-logging-broker-enabled": false,
                    "is-logging-enabled-on-all-devices": false
                },
                // Logging all NETCONF notification messages.
                {
                    "broker-identifier": "netconf_notifications",
                    "is-logging-broker-enabled": false,
                    "is-logging-enabled-on-all-devices": false
                },
                // Logging all CLI commands and responses.
                {
                    "broker-identifier": "cli_messages",
                    "is-logging-broker-enabled": false,
                    "is-logging-enabled-on-all-devices": false
                },
                // Logging RESTCONF requests and responses.
                {
                    "broker-identifier": "restconf",
                    "is-logging-broker-enabled": false
                    // HTTP headers which content is removed from logs.
                    //"restconf-logging:hidden-http-headers": [
                    //    "Authorization",
                    //    "Cookie"
                    //],
                    // HTTP operations that are not logged.
                    //"restconf-logging:hidden-http-methods": [
                    //    "GET"
                    //]
                }
            ]
        },
        // cryptographic settings
        "crypto": {
            // identifier of YANG extension that is responsible for marking of leaves/leaf-lists that must be encrypted
            // "encryptExtensionId": "frinx-encrypt:encrypt",
            // name of YANG module from which the correct revision of 'netconfEncryptedPathsModuleName' is chosen
            // "netconfReferenceModuleName": "system",
            // name of YANG module which contains deviations to leaves/leaf-lists that must be encrypted
            // "netconfEncryptedPathsModuleName": "encrypted-paths"
        },
        // settings for metrics
        "metrics": {
                // flag that determines if metrics will be reported or not
                "enabled": true,
                // reporter type (log, csv)
                "reporter": "log",
                // reporting rate in seconds
                "rate": 30
            // example csv output for one metric
            //        t,count,mean_rate,m1_rate,m5_rate,m15_rate,rate_unit
            //        1650557436,3,0.182204,0.507889,0.580330,0.593370,events/second
            //        1650557466,3,0.064564,0.308050,0.525104,0.573917,events/second
            //        1650557496,3,0.039233,0.186842,0.475134,0.555102,events/second
            //        1650557526,3,0.028178,0.113325,0.429919,0.536904,events/second
            //        1650557534,3,0.026281,0.104264,0.422813,0.533929,events/second
            //
            // example log output
            // 18:16:20.886 INFO io.frinx.uniconfig.metrics.impl.ReporterImpl - type=GAUGE, name=io.frinx.uniconfig.manager.impl.task.TaskExecutorImpl.queue_size, value=0
            // 18:16:20.887 INFO io.frinx.uniconfig.metrics.impl.ReporterImpl - type=METER, name=org.opendaylight.controller.uniconfig.transaction.manager.impl.UniconfigTransactionManagerImpl.transaction_invoke, count=0, m1_rate=0.0, m5_rate=0.0, m15_rate=0.0, mean_rate=0.0, rate_unit=events/second
            // 18:16:20.887 INFO io.frinx.uniconfig.metrics.impl.ReporterImpl - type=METER, name=org.opendaylight.yangtools.yang.common.RpcResult.rpc_invoke, count=3, m1_rate=0.3080502714195554, m5_rate=0.5251039914257685, m15_rate=0.5739172434618175, mean_rate=0.06565517632771098, rate_unit=events/second
  
        }
    }
---
# Source: uniconfig/templates/configmap-logback.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: uniconfig-controller-configmap-logback
data:
  logback.xml: |-
    <?xml version="1.0" encoding="UTF-8"?>
  
    <!-- For assistance related to logback-translator or configuration  -->
    <!-- files in general, please contact the logback user mailing list -->
    <!-- at http://www.qos.ch/mailman/listinfo/logback-user             -->
    <!--                                                                -->
    <!-- For professional support please see                            -->
    <!--    http://www.qos.ch/shop/products/professionalSupport         -->
    <!--                                                                -->
    <configuration scan="true" debug="true" scanPeriod="5 seconds">
        <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{HH:mm:ss.SSS} %level %logger - %msg%n</pattern>
            </encoder>
        </appender>
        <appender name="logs" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <File>log/${SERVICE_NAME}/${CONTAINER_ID}/logs.log</File>
            <encoder>
                <pattern>%d{HH:mm:ss.SSS} %level %logger - %msg%n</pattern>
            </encoder>
            <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
                <maxIndex>20</maxIndex>
                <FileNamePattern>log/${SERVICE_NAME}/${CONTAINER_ID}/logs.log.%i</FileNamePattern>
            </rollingPolicy>
            <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                <MaxFileSize>50MB</MaxFileSize>
            </triggeringPolicy>
        </appender>
        <appender name="netconf-notifications" class="ch.qos.logback.classic.sift.SiftingAppender">
            <discriminator class="io.lighty.discriminator.MarkerBasedDiscriminator">
                <key>deviceName</key>
                <defaultValue>unknown</defaultValue>
            </discriminator>
            <sift>
                <appender name="${deviceName}-netconf-notifications" class="ch.qos.logback.core.rolling.RollingFileAppender">
                    <file>log/${SERVICE_NAME}/${CONTAINER_ID}/netconf-notifications/${deviceName}.log</file>
                    <encoder>
                        <pattern>%d{HH:mm:ss.SSS} %level %logger - %msg%n</pattern>
                    </encoder>
                    <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
                        <maxIndex>20</maxIndex>
                        <FileNamePattern>log/${SERVICE_NAME}/${CONTAINER_ID}/netconf-notifications/${deviceName}.log.%i</FileNamePattern>
                    </rollingPolicy>
                    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                        <MaxFileSize>16MB</MaxFileSize>
                    </triggeringPolicy>
                </appender>
            </sift>
        </appender>
        <appender name="netconf-messages" class="ch.qos.logback.classic.sift.SiftingAppender">
            <discriminator class="io.lighty.discriminator.MarkerBasedDiscriminator">
                <key>deviceName</key>
                <defaultValue>unknown</defaultValue>
            </discriminator>
            <sift>
                <appender name="${deviceName}-netconf-messages" class="ch.qos.logback.core.rolling.RollingFileAppender">
                    <file>log/${SERVICE_NAME}/${CONTAINER_ID}/netconf-messages/${deviceName}.log</file>
                    <encoder>
                        <pattern>%d{HH:mm:ss.SSS} %level %logger - %msg%n</pattern>
                    </encoder>
                    <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
                        <maxIndex>20</maxIndex>
                        <FileNamePattern>log/${SERVICE_NAME}/${CONTAINER_ID}/netconf-messages/${deviceName}.log.%i</FileNamePattern>
                    </rollingPolicy>
                    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                        <MaxFileSize>16MB</MaxFileSize>
                    </triggeringPolicy>
                </appender>
            </sift>
        </appender>
        <appender name="netconf-events" class="ch.qos.logback.classic.sift.SiftingAppender">
            <discriminator class="io.lighty.discriminator.MarkerBasedDiscriminator">
                <key>deviceName</key>
                <defaultValue>unknown</defaultValue>
            </discriminator>
            <sift>
                <appender name="${deviceName}-netconf-events" class="ch.qos.logback.core.rolling.RollingFileAppender">
                    <file>log/${SERVICE_NAME}/${CONTAINER_ID}/netconf-events/${deviceName}.log</file>
                    <encoder>
                        <pattern>%d{HH:mm:ss.SSS} %level %logger - %msg%n</pattern>
                    </encoder>
                    <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
                        <maxIndex>20</maxIndex>
                        <FileNamePattern>log/${SERVICE_NAME}/${CONTAINER_ID}/netconf-events/${deviceName}.log.%i</FileNamePattern>
                    </rollingPolicy>
                    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                        <MaxFileSize>16MB</MaxFileSize>
                    </triggeringPolicy>
                </appender>
            </sift>
        </appender>
        <appender name="restconf" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <File>log/${SERVICE_NAME}/${CONTAINER_ID}/restconf.log</File>
            <encoder>
                <pattern>%d{HH:mm:ss.SSS} %level %logger - %msg%n</pattern>
            </encoder>
            <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
                <maxIndex>20</maxIndex>
                <FileNamePattern>log/${SERVICE_NAME}/${CONTAINER_ID}/restconf.%i</FileNamePattern>
            </rollingPolicy>
            <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                <MaxFileSize>50MB</MaxFileSize>
            </triggeringPolicy>
        </appender>
        <appender name="cli-messages" class="ch.qos.logback.classic.sift.SiftingAppender">
            <discriminator class="io.lighty.discriminator.MarkerBasedDiscriminator">
                <key>deviceName</key>
                <defaultValue>unknown</defaultValue>
            </discriminator>
            <sift>
                <appender name="${deviceName}-cli-messages" class="ch.qos.logback.core.rolling.RollingFileAppender">
                    <file>log/${SERVICE_NAME}/${CONTAINER_ID}/cli-messages/${deviceName}.log</file>
                    <encoder>
                        <pattern>%d{HH:mm:ss.SSS} %level %logger - %msg%n</pattern>
                    </encoder>
                    <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
                        <maxIndex>20</maxIndex>
                        <FileNamePattern>log/${SERVICE_NAME}/${CONTAINER_ID}/cli-messages/${deviceName}.log.%i</FileNamePattern>
                    </rollingPolicy>
                    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                        <MaxFileSize>16MB</MaxFileSize>
                    </triggeringPolicy>
                </appender>
            </sift>
        </appender>
  
        <appender name="gnmi" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <File>log/${SERVICE_NAME}/${CONTAINER_ID}/gnmi.log</File>
            <encoder>
                <pattern>%d{HH:mm:ss} %level %logger - %msg%n</pattern>
            </encoder>
            <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
                <maxIndex>20</maxIndex>
                <FileNamePattern>log/${SERVICE_NAME}/${CONTAINER_ID}/gnmi.log.%i</FileNamePattern>
            </rollingPolicy>
            <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                <MaxFileSize>16MB</MaxFileSize>
            </triggeringPolicy>
        </appender>
  
        <appender name="metrics" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <File>log/${SERVICE_NAME}/${CONTAINER_ID}/metrics.log</File>
            <encoder>
                <pattern> uniconfig,zone=${SERVICE_NAME},instance=${CONTAINER_ID} %replace(%replace(%msg){'=','="'}){', ','",'}"%n </pattern>
            </encoder>
            <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
                <maxIndex>20</maxIndex>
                <FileNamePattern>log/${SERVICE_NAME}/${CONTAINER_ID}/metrics.log.%i</FileNamePattern>
            </rollingPolicy>
            <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                <MaxFileSize>16MB</MaxFileSize>
            </triggeringPolicy>
        </appender>
  
        <!-- used for automatic propagation of set logger level to JUL logging implementation -->
        <contextListener class="ch.qos.logback.classic.jul.LevelChangePropagator">
            <resetJUL>true</resetJUL>
        </contextListener>
  
        <!-- root logger -->
        <root level="INFO">
            <appender-ref ref="STDOUT"/>
            <appender-ref ref="logs"/>
        </root>
  
        <!-- UniConfig layer part -->
        <logger name="io.frinx.uniconfig" level="INFO"/>
  
        <!-- Unified layer part -->
        <logger name="io.frinx.unitopo" level="INFO"/>
  
        <!-- NETCONF part -->
        <logger name="org.opendaylight.netconf" level="INFO"/>
  
        <!-- CLI part -->
        <logger name="io.frinx.cli" level="INFO"/>
  
        <!-- SSH part (used by CLI and NETCONF) -->
        <logger name="org.apache.sshd" level="INFO"/>
  
        <!-- translation unit framework part -->
        <logger name="io.frinx.translate.unit.commons" level="INFO"/>
        <logger name="io.fd.honeycomb" level="INFO"/>
  
        <logger name="io.lighty.gnmi" level="DEBUG" additivity="false">
            <appender-ref ref="STDOUT"/>
            <appender-ref ref="logs"/>
            <appender-ref ref="gnmi"/>
        </logger>
  
        <!-- RESTCONF part -->
        <logger name="org.opendaylight.restconf" level="INFO"/>
        <logger name="org.opendaylight.aaa" level="INFO"/>
  
        <!-- controller part -->
        <logger name="org.opendaylight.daexim" level="INFO"/>
        <logger name="org.opendaylight.controller" level="INFO"/>
        <logger name="org.opendaylight.yangtools" level="INFO"/>
  
        <!-- Kafka -->
        <logger name="org.apache.kafka.clients.NetworkClient" level="INFO"/>
  
        <!-- Metrics -->
        <logger name="io.frinx.uniconfig.metrics" level="INFO" additivity="false">
            <appender-ref ref="metrics"/>
        </logger>
  
        <!-- PostgreSQL driver -->
        <logger name="org.postgresql" level="INFO"/>
  
        <!-- do not modify this part, we should use RESTCONF RPCs for controlling of logging brokers -->
        <logger name="org.opendaylight.restconf.nb.rfc8040.jersey.providers.logging.RestconfLoggingBroker" level="INFO" additivity="false">
            <appender-ref ref="restconf"/>
            <appender-ref ref="STDOUT"/>
        </logger>
        <logger name="org.opendaylight.netconf.logging.brokers.NetconfMessagesLoggingBroker" level="INFO" additivity="false">
            <appender-ref ref="netconf-messages"/>
            <appender-ref ref="STDOUT"/>
        </logger>
        <logger name="org.opendaylight.netconf.logging.brokers.NotificationsLoggingBroker" level="INFO" additivity="false">
            <appender-ref ref="netconf-notifications"/>
            <appender-ref ref="STDOUT"/>
        </logger>
        <logger name="org.opendaylight.netconf.logging.brokers.NetconfEventsLoggingBroker" level="INFO" additivity="false">
            <appender-ref ref="netconf-events"/>
            <appender-ref ref="STDOUT"/>
        </logger>
        <logger name="io.frinx.cli.io.impl.cli.CliLoggingBroker" level="INFO" additivity="false">
            <appender-ref ref="cli-messages"/>
            <appender-ref ref="STDOUT"/>
        </logger>
    </configuration>
---
# Source: uniconfig/templates/configmap-uniconfig-script.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: uniconfig-controller-configmap-uniconfig-script
data:
  run_uniconfig.sh: |
    #!/bin/bash
  
    CONFIG="config/lighty-uniconfig-config.json"
    JAR_DIRS="./*:./libs/*:./config"
    MAIN_CLASS="io.frinx.lighty_uniconfig.Main"
    JAVA_MAX_MEM=${JAVA_MAX_MEM:="4G"}
    DEBUG_PARAMETER="--debug"
    UNICONFIG_ID=${CONTAINER_ID:=1}
    PROXY_ENABLED=${PROXY_ENABLED:="false"}
  
    # set sensitive env variables from docker secrets
    if [[ -f "/set_env_secrets.sh" ]]; then
      . /set_env_secrets.sh ''
    fi
  
    display_usage() {
        echo -e "Usage: $(basename "$0") [-f] [-l LICENSE_TOKEN] [--debug]"
        echo -e "where: "
        echo -e "   -l LICENSE_TOKEN : license token for running Frinx Uniconfig"
        echo -e "   -f               : new license token is forced (overwrites old license)"
        echo -e "   --debug          : enabled java debugging on port 5005"
    }
  
    is_system_proxy_enabled() {
        unset PROXY_PORT PROXY_HOST
        local PROXY_URL="$1"
        if [[ "${PROXY_URL}" == "http"* ]] && [[ $(echo "${PROXY_URL}" | tr -d -c ":" | wc -m) -eq 2 ]]; then
            PROXY_PORT="$(echo "${PROXY_URL}"| cut -d ':' -f 3 | sed 's,[^0-9]*,,g')"
            PROXY_HOST="$(echo "${PROXY_URL}"| cut -d ':' -f 2 | sed 's,//,,')"
        elif [[ "${PROXY_URL}" =~ ^[[:digit:]] ]] && [[ $(echo "${PROXY_URL}" | tr -d -c ":" | wc -m) -eq 1 ]]; then
            PROXY_PORT="$(echo "${PROXY_URL}"| cut -d ':' -f 2 | sed 's,[^0-9]*,,g')"
            PROXY_HOST="${PROXY_HOST}$(echo "${PROXY_URL}"| cut -d ':' -f 1)"
        else
            echo -e ${ERROR} "Used bad HTTP Proxy format ${PROXY_URL}"
            exit 1
        fi
        eval "$3=-D${2}.proxyHost=${PROXY_HOST}"
        eval "$4=-D${2}.proxyPort=${PROXY_PORT}"
    }
  
    is_enabled_debugging() {
      for arg in "$@"; do
        if [ "$arg" = $DEBUG_PARAMETER ]; then
          return 1
        fi
      done
      return 0
    }
  
    delete_debug_argument() {
      filtered_args=("$@")
      for i in "${!filtered_args[@]}"; do
        if [ "${filtered_args[i]}" = "$DEBUG_PARAMETER" ]; then
          unset 'filtered_args[i]'
        fi
      done
    }
  
    for i in "$@"
    do
    case $i in
        -h|--help)
        display_usage
        exit 0
        ;;
    esac
    done
  
    if [[ ${PROXY_ENABLED} == "true" ]]; then
      is_system_proxy_enabled $HTTP_PROXY "http" __HTTP_HOST __HTTP_PORT
      is_system_proxy_enabled $HTTPS_PROXY "https" __HTTPS_HOST __HTTPS_PORT
      _JAVA_OPTIONS="$_JAVA_OPTIONS ${__HTTP_HOST} ${__HTTP_PORT} ${__HTTPS_HOST} ${__HTTPS_PORT} -Dhttp.nonProxyHosts=${NO_PROXY}"
    fi
  
    mkdir -p log/${SERVICE_NAME}/${UNICONFIG_ID}
  
    # removing cached data and logs from previous run
    rm -rf snapshots/ journal/
  
    # folder where lighty stores data
    mkdir -m 700 -p data
  
    # wait for postgresql container
    sleep 5
  
    is_enabled_debugging "$@"; enabled_debugging=$?
    if [ $enabled_debugging -eq 1 ]; then
      delete_debug_argument "$@"
      java "-Xmx${JAVA_MAX_MEM}" -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 -cp "${JAR_DIRS}" \
        "${MAIN_CLASS}" -c "${CONFIG}" "${filtered_args[@]}"; unset filtered_args
    else
      java "-Xmx${JAVA_MAX_MEM}" -cp "${JAR_DIRS}" "${MAIN_CLASS}" -c "${CONFIG}" "$@"
    fi
    unset enabled_debugging
---
# Source: uniconfig/charts/traefik/templates/rbac/clusterrole.yaml
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: uniconfig-default
  labels:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/instance: fm-default
    helm.sh/chart: traefik-20.8.0
    app.kubernetes.io/managed-by: Helm
rules:
  - apiGroups:
      - extensions
      - networking.k8s.io
    resources:
      - ingressclasses
      - ingresses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - services
      - endpoints
      - secrets
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - extensions
      - networking.k8s.io
    resources:
      - ingresses/status
    verbs:
      - update
  - apiGroups:
      - traefik.containo.us
    resources:
      - ingressroutes
      - ingressroutetcps
      - ingressrouteudps
      - middlewares
      - middlewaretcps
      - tlsoptions
      - tlsstores
      - traefikservices
      - serverstransports
    verbs:
      - get
      - list
      - watch
---
# Source: uniconfig/charts/traefik/templates/rbac/clusterrolebinding.yaml
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: uniconfig-default
  labels:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/instance: fm-default
    helm.sh/chart: traefik-20.8.0
    app.kubernetes.io/managed-by: Helm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: uniconfig-default
subjects:
  - kind: ServiceAccount
    name: uniconfig
    namespace: default
---
# Source: uniconfig/charts/postgresql/templates/primary/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: fm-postgresql-hl
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.9.13
    app.kubernetes.io/instance: fm
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: primary
    # Use this annotation in addition to the actual publishNotReadyAddresses
    # field below because the annotation will stop being respected soon but the
    # field is broken in some versions of Kubernetes:
    # https://github.com/kubernetes/kubernetes/issues/58662
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
spec:
  type: ClusterIP
  clusterIP: None
  # We want all pods in the StatefulSet to have their addresses published for
  # the sake of the other Postgresql pods even before they're ready, since they
  # have to be able to talk to each other in order to become ready.
  publishNotReadyAddresses: true
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: fm
    app.kubernetes.io/component: primary
---
# Source: uniconfig/charts/postgresql/templates/primary/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: fm-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.9.13
    app.kubernetes.io/instance: fm
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: primary
  annotations:
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
      nodePort: null
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: fm
    app.kubernetes.io/component: primary
---
# Source: uniconfig/charts/traefik/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: uniconfig
  namespace: default
  labels:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/instance: fm-default
    helm.sh/chart: traefik-20.8.0
    app.kubernetes.io/managed-by: Helm
  annotations:
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/instance: fm-default
  ports:
  - port: 8181
    name: "uniconfig"
    targetPort: uniconfig
    protocol: TCP
  - port: 80
    name: "web"
    targetPort: web
    protocol: TCP
  - port: 443
    name: "websecure"
    targetPort: websecure
    protocol: TCP
---
# Source: uniconfig/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: uniconfig-controller
  labels:
    helm.sh/chart: uniconfig-3.0.4
    app.kubernetes.io/name: uniconfig
    app.kubernetes.io/instance: fm
    app.kubernetes.io/version: "5.0.12"
    app.kubernetes.io/managed-by: Helm
  annotations:
    traefik.ingress.kubernetes.io/service.passhostheader: "true"
    traefik.ingress.kubernetes.io/service.sticky.cookie: "true"
    traefik.ingress.kubernetes.io/service.sticky.cookie.name: uniconfig_server_id
spec:
  type: ClusterIP
  ports:
    - port: 8181
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: uniconfig
    app.kubernetes.io/instance: fm
---
# Source: uniconfig/charts/traefik/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: uniconfig
  namespace: default
  labels:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/instance: fm-default
    helm.sh/chart: traefik-20.8.0
    app.kubernetes.io/managed-by: Helm
  annotations:
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: traefik
      app.kubernetes.io/instance: fm-default
  strategy: 
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
    type: RollingUpdate
  minReadySeconds: 0
  template: 
    metadata:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/path: "/metrics"
        prometheus.io/port: "9100"
      labels:
        app.kubernetes.io/name: traefik
        app.kubernetes.io/instance: fm-default
        helm.sh/chart: traefik-20.8.0
        app.kubernetes.io/managed-by: Helm
    spec:
      serviceAccountName: uniconfig
      terminationGracePeriodSeconds: 60
      hostNetwork: false
      containers:
      - image: traefik:v2.9.6
        imagePullPolicy: IfNotPresent
        name: uniconfig
        resources:
        readinessProbe:
          httpGet:
            path: /ping
            port: 9000
            scheme: HTTP
          failureThreshold: 1
          initialDelaySeconds: 2
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 2
        livenessProbe:
          httpGet:
            path: /ping
            port: 9000
            scheme: HTTP
          failureThreshold: 3
          initialDelaySeconds: 2
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 2
        lifecycle:
        ports:
        - name: "metrics"
          containerPort: 9100
          protocol: "TCP"
        - name: "traefik"
          containerPort: 9000
          protocol: "TCP"
        - name: "uniconfig"
          containerPort: 8181
          protocol: "TCP"
        - name: "web"
          containerPort: 8000
          protocol: "TCP"
        - name: "websecure"
          containerPort: 8443
          protocol: "TCP"
        securityContext:
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
          runAsGroup: 65532
          runAsNonRoot: true
          runAsUser: 65532
        volumeMounts:
          - name: data
            mountPath: /data
          - name: tmp
            mountPath: /tmp
        args:
          - "--global.checknewversion"
          - "--global.sendanonymoususage"
          - "--entrypoints.metrics.address=:9100/tcp"
          - "--entrypoints.traefik.address=:9000/tcp"
          - "--entrypoints.uniconfig.address=:8181/tcp"
          - "--entrypoints.web.address=:8000/tcp"
          - "--entrypoints.websecure.address=:8443/tcp"
          - "--api.dashboard=true"
          - "--ping=true"
          - "--metrics.prometheus=true"
          - "--metrics.prometheus.entrypoint=metrics"
          - "--providers.kubernetescrd"
          - "--providers.kubernetesingress"
          - "--entrypoints.websecure.http.tls=true"
      volumes:
        - name: data
          emptyDir: {}
        - name: tmp
          emptyDir: {}
      securityContext:
        fsGroup: 65532
---
# Source: uniconfig/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: uniconfig-controller
  labels:
    helm.sh/chart: uniconfig-3.0.4
    app.kubernetes.io/name: uniconfig
    app.kubernetes.io/instance: fm
    app.kubernetes.io/version: "5.0.12"
    app.kubernetes.io/managed-by: Helm
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: uniconfig
      app.kubernetes.io/instance: fm
  template:
    metadata:
      annotations:
      labels:
        app.kubernetes.io/name: uniconfig
        app.kubernetes.io/instance: fm
    spec:
      volumes:
        - name: uniconfig-frinx-volume
          emptyDir: {}
        - name: frinx-uniconfig-controller-logs
          emptyDir: {}
        - name: uniconfig-script
          configMap:
            name: uniconfig-controller-configmap-uniconfig-script
            defaultMode: 0777
            items:
            - key: run_uniconfig.sh
              path: run_uniconfig.sh
        - name: logback
          configMap:
            name: uniconfig-controller-configmap-logback
            defaultMode: 0777
            items:
            - key: logback.xml
              path: logback.xml
        - name: lighty-uniconfig-config
          configMap:
            name: uniconfig-controller-configmap-lighty-uniconfig-config
            defaultMode: 0777
            items:
            - key: lighty-uniconfig-config.json
              path: lighty-uniconfig-config.json
      serviceAccountName: uniconfig-controller
      securityContext:
        {}
      initContainers:
      
        - name: check-db-ready
          image: postgres:alpine
          command: ['sh', '-c',
            "until pg_isready -h fm-postgresql -p 5432 -U postgresU;
            do echo waiting for database; sleep 2; done;"]
      
        - name: copy-config-files
          image: "frinx/uniconfig:5.0.12"
          command:
            - sh
            - '-c'
            - 'cp -r /opt/uniconfig-frinx/* /tmp/uniconfig-frinx/'
          volumeMounts:
            - name: uniconfig-frinx-volume
              mountPath: /tmp/uniconfig-frinx/
        
      containers:
        - name: uniconfig
          securityContext:
            capabilities:
              add:
              - CAP_NET_BIND_SERVICE
              - NET_ADMIN
              drop:
              - ALL
          image: "frinx/uniconfig:5.0.12"
          imagePullPolicy: IfNotPresent
          args: ["-f", "-l", "e326aaa7b1741bb530d201c49f4311d3d0f391893e15393894a77180e6478289cd1709e4afe3a643100ccd31052430de1955540cf5ae1e510d657bd2af8ef2fc"]
          env:
            - name: CONTAINER_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: SERVICE_NAME
              value: "uniconfig"
            - name: PROXY_ENABLED
              value: "false"
            - name: HTTP_PROXY
              value: 
            - name: HTTPS_PROXY
              value: 
            - name: NO_PROXY
              value: 
            - name: JAVA_MAX_MEM
              value: "10G"
            - name: _JAVA_OPTIONS
              value: "-Xmx$(JAVA_MAX_MEM) -XX:+AlwaysPreTouch -Djna.nosys=true -XX:+AlwaysPreTouch -Djna.nosys=true -XX:+CrashOnOutOfMemoryError -XX:MaxGCPauseMillis=200 -Xlog:gc:/opt/uniconfig-frinx/log/$(SERVICE_NAME)/$(CONTAINER_ID)/gc.log:tags,time,uptime,level:filecount=10,filesize=5M -XX:+UseG1GC -XX:+ExplicitGCInvokesConcurrent -XX:+ParallelRefProcEnabled -XX:+UseStringDeduplication -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=20 -XX:+UnlockDiagnosticVMOptions -XX:G1SummarizeRSetStatsPeriod=1"
            - name: tls_keystorePassword 
              value: "password"
            - name: dbPersistence_enabled
              value: "true"
            - name: dbPersistence_connection_dbName
              value: uniconfig
            - name: dbPersistence_connection_username
              valueFrom:
                secretKeyRef:
                  name: uniconfig-controller
                  key: dbPersistence_connection_username
            - name: dbPersistence_connection_password
              valueFrom:
                secretKeyRef:
                  name: uniconfig-controller
                  key: dbPersistence_connection_password
            - name: dbPersistence_connection_databaseLocations_host
              value: "fm-postgresql"
              
            - name: dbPersistence_connection_databaseLocations_port
              value: "5432"
          volumeMounts:
          - name: frinx-uniconfig-controller-logs
            mountPath: /opt/uniconfig-frinx/log
          - name: uniconfig-frinx-volume
            mountPath: /opt/uniconfig-frinx
          - name: uniconfig-script
            mountPath: /opt/uniconfig-frinx/run_uniconfig.sh
            subPath: run_uniconfig.sh
          - name: logback
            mountPath: /opt/uniconfig-frinx/config/logback.xml
            subPath: logback.xml
          - name: lighty-uniconfig-config
            mountPath: /opt/uniconfig-frinx/config/lighty-uniconfig-config.json
            subPath: lighty-uniconfig-config.json
          ports:
            - name: http
              containerPort: 8181
              protocol: TCP
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - 'curl --insecure -o /dev/null --silent --write-out "%{http_code}" -X POST localhost:8181/rests/operations/uniconfig-manager:health -H "Content-Type:application/json"'
            initialDelaySeconds: 60
            timeoutSeconds: 35
            failureThreshold: 20
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - 'curl --insecure -o /dev/null --silent --write-out "%{http_code}" -X POST localhost:8181/rests/operations/uniconfig-manager:health -H "Content-Type:application/json"'
            initialDelaySeconds: 60
            timeoutSeconds: 35
            failureThreshold: 20
          resources:
            {}
---
# Source: uniconfig/charts/postgresql/templates/primary/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: fm-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.9.13
    app.kubernetes.io/instance: fm
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: primary
  annotations:
spec:
  replicas: 1
  serviceName: fm-postgresql-hl
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/instance: fm
      app.kubernetes.io/component: primary
  template:
    metadata:
      name: fm-postgresql
      labels:
        app.kubernetes.io/name: postgresql
        helm.sh/chart: postgresql-11.9.13
        app.kubernetes.io/instance: fm
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: primary
      annotations:
    spec:
      serviceAccountName: default
      
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: postgresql
                    app.kubernetes.io/instance: fm
                    app.kubernetes.io/component: primary
                namespaces:
                  - "default"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      securityContext:
        fsGroup: 1001
      hostNetwork: false
      hostIPC: false
      initContainers:
      containers:
        - name: postgresql
          image: docker.io/bitnami/postgresql:14.5.0-debian-11-r35
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: POSTGRESQL_PORT_NUMBER
              value: "5432"
            - name: POSTGRESQL_VOLUME_DIR
              value: "/bitnami/postgresql"
            - name: PGDATA
              value: "/bitnami/postgresql/data"
            # Authentication
            - name: POSTGRES_USER
              value: "postgresU"
            - name: POSTGRES_POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: fm-postgresql
                  key: postgres-password
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: fm-postgresql
                  key: password
            - name: POSTGRES_DB
              value: "uniconfig"
            # Replication
            # Initdb
            # Standby
            # LDAP
            - name: POSTGRESQL_ENABLE_LDAP
              value: "no"
            # TLS
            - name: POSTGRESQL_ENABLE_TLS
              value: "no"
            # Audit
            - name: POSTGRESQL_LOG_HOSTNAME
              value: "false"
            - name: POSTGRESQL_LOG_CONNECTIONS
              value: "false"
            - name: POSTGRESQL_LOG_DISCONNECTIONS
              value: "false"
            - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
              value: "off"
            # Others
            - name: POSTGRESQL_CLIENT_MIN_MESSAGES
              value: "error"
            - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
              value: "pgaudit"
          ports:
            - name: tcp-postgresql
              containerPort: 5432
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - exec pg_isready -U "postgresU" -d "dbname=uniconfig" -h 127.0.0.1 -p 5432
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - -e
                
                - |
                  exec pg_isready -U "postgresU" -d "dbname=uniconfig" -h 127.0.0.1 -p 5432
                  [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]
          resources:
            limits: {}
            requests:
              cpu: 250m
              memory: 256Mi
          volumeMounts:
            - name: dshm
              mountPath: /dev/shm
            - name: data
              mountPath: /bitnami/postgresql
      volumes:
        - name: dshm
          emptyDir:
            medium: Memory
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: uniconfig/charts/traefik/templates/ingressclass.yaml
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  annotations:
    ingressclass.kubernetes.io/is-default-class: "true"
  labels:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/instance: fm-default
    helm.sh/chart: traefik-20.8.0
    app.kubernetes.io/managed-by: Helm
  name: uniconfig
spec:
  controller: traefik.io/ingress-controller
---
# Source: uniconfig/templates/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: uniconfig-controller
  labels:
    helm.sh/chart: uniconfig-3.0.4
    app.kubernetes.io/name: uniconfig
    app.kubernetes.io/instance: fm
    app.kubernetes.io/version: "5.0.12"
    app.kubernetes.io/managed-by: Helm
  annotations:
    kubernetes.io/ingress.class: traefik-uniconfig
spec:
  defaultBackend:
    service:
      name: uniconfig-controller
      port:
        number: 8181
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: uniconfig-controller
                port:
                  number: 8181
---
# Source: uniconfig/templates/tests/test-connection.yaml
apiVersion: v1
kind: Pod
metadata:
  name: "uniconfig-controller-test-connection"
  labels:
    helm.sh/chart: uniconfig-3.0.4
    app.kubernetes.io/name: uniconfig
    app.kubernetes.io/instance: fm
    app.kubernetes.io/version: "5.0.12"
    app.kubernetes.io/managed-by: Helm
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: check-uniconfig
      image: curlimages/curl
      command: ["/bin/sh","-c"]
      args: ['curl --fail --insecure -o /dev/null --silent --write-out "%{http_code}" -X POST uniconfig:8181/rests/operations/uniconfig-manager:health -H "Content-Type:application/json"']
  restartPolicy: Never
---
# Source: uniconfig/charts/traefik/templates/dashboard-hook-ingressroute.yaml
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: uniconfig-dashboard
  namespace: default
  annotations:
    helm.sh/hook: "post-install,post-upgrade"
    meta.helm.sh/release-name: fm
    meta.helm.sh/release-namespace: default
  labels:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/instance: fm-default
    helm.sh/chart: traefik-20.8.0
    app.kubernetes.io/managed-by: Helm
spec:
  entryPoints:
  - traefik
  routes:
  - match: PathPrefix(`/dashboard`) || PathPrefix(`/api`)
    kind: Rule
    services:
    - name: api@internal
      kind: TraefikService
